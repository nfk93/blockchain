/* Lexical Part */

comma       : ',' ;
geq         : '>' '=' ;
gt          : '>' ;
leq         : '<' '=' ;
larrow      : '<' '-' ;
neq         : '<' '>' ;
lt          : '<' ;
rarrow      : '-' '>' ;
eq          : '=' ;
plus        : '+' ;
minus       : '-' ;
lbrace      : '{' ;
rbrace      : '}' ;
lbrack      : '[' ;
rbrack      : ']' ;
lparen      : '(' ;
rparen      : ')' ;
colon       : ':' ;
semicolon   : ';' ;
ast         : '*' ;
keyhash     : 'k' 'e' 'y' '_' 'h' 'a' 's' 'h' ;
operation   : 'o' 'p' 'e' 'r' 'a' 't' 'i' 'o' 'n' ;
list        : 'l' 'i' 's' 't' ;
bool        : 'b' 'o' 'o' 'l' ;
int         : 'i' 'n' 't' ;
string      : 's' 't' 'r' 'i' 'n' 'g' ;
false       : 'f' 'a' 'l' 's' 'e' ;
true        : 't' 'r' 'u' 'e' ;
letinit     : 'l' 'e' 't' '%' 'i' 'n' 'i' 't' ;
letentry    : 'l' 'e' 't' '%' 'e' 'n' 't' 'r' 'y' ;
let         : 'l' 'e' 't' ;  // has to go after the other lets
in          : 'i' 'n' ;
if          : 'i' 'f' ;
then        : 't' 'h' 'e' 'n' ;
else        : 'e' 'l' 's' 'e' ;
type        : 't' 'y' 'p' 'e' ;
tez         : 't' 'e' 'z' ;

/* TODO: make sure hashes without capital letters can be distinguished from ids */
_b58char    :  '1'-'9' | 'A'-'H' | 'J'-'N' | 'P'-'Z' | 'a'-'k' | 'm'-'z' ;
hash        : 'k' 'o' 'i' 'n' _b58char { _b58char } ;

/* id's are all minor case in liquidity, starting with a letter */
_idchars    : 'a'-'z' | 'A'-'Z' | '0'-'9' | '_'  ;
lident      : ( 'a'-'z' | '_' ) { _idchars } ;
uident      : ( 'A'-'Z' ) { _idchars } ;

/* TODO: escape chars */
string_lit  : '"' {.} '"' ;

_digit      : '0'-'9' ;
_amount     : _digit { _digit } ;
tez_lit     : _amount 't' 'z' ;
int_lit     : _digit { _digit } ;
float_lit   : _digit { _digit } '.' { _digit } ;

/* This must go below float detection, for obvious reasons */
dot         : '.' ;

/* Comments are treated as whitespace. As are version identifier TODO */
_comment    : '(' '*' {.} '*' ')' ;
_version    : '[' '%' '%' 'v' 'e' 'r' 's' 'i' 'o' 'n' ' ' {.} ']' ;
!whitespace : ' ' | '\t' | '\n' | '\r' | _comment | _version ;




/* Syntax Part */

<< import "github.com/nfk93/blockchain/interpreter/ast" >>

Toplevel    : Structure                                                             << ast.NewStructure($0) >>
            | Toplevel Structure                                                    << ast.NewTodoExp() >> ;


Structure   : ModStruct                                                             << ast.NewModStruct($0) // >>
            | letinit Exp                                                           << ast.NewTodoExp() // >>
            | letentry lident Pattern Pattern eq Exp                                << ast.NewTodoExp() // >> ;

ModStruct   : type lident eq Type                                                   << ast.NewSimpleTypeDecl($1, $3) // >>
            | type lident eq lbrack Struct rbrack                                   << ast.NewTodoExp() // >> ;

Struct      : lident colon Type semicolon Struct                                    << ast.NewTodoExp() // >>
            | lident colon Type semicolon                                           << ast.NewTodoExp() // >> ;

Exp         : lident                                                                << ast.NewTodoExp() // idexp >>
            | uident dot lident                                                     << ast.NewTodoExp() // external lookup exp >>
            | Lookup lident                                                         << ast.NewTodoExp() // lookupexp >>
            | Lookup lident larrow Exp                                              << ast.NewTodoExp() // lookupexp >>
            | if Exp then Exp else Exp                                              << ast.NewTodoExp() // ifthenelse exp >>
            | if Exp then Exp                                                       << ast.NewTodoExp() // ifthen exp >>
            | Exp semicolon Exp                                                     << ast.NewTodoExp() // seqexp >>
            | Exp colon colon Exp                                                   << ast.NewTodoExp() // listconcat >>
            | let Pattern eq Exp in Exp                                             << ast.NewTodoExp() // letexp >>
            | Constant                                                              << ast.NewTodoExp() // litexp >> ;

Lookup      : Lookup lident dot                                                     << ast.NewTodoExp() // intermediate for lookup calls  >>
            | lident dot                                                            << ast.NewTodoExp() // see above >> ;

Pattern     : lident                                                                << ast.NewTodoExp() // param >>
            | lparen PatternSeq rparen                                              << ast.NewTodoExp() // params >>
            | lparen lident colon Type rparen                                       << ast.NewTodoExp() // typedparam >> ;

PatternSeq  : Pattern                                                               << ast.NewTodoExp() // intermediate for pattern sequences  >>
            | PatternSeq comma PatternSeq                                           << ast.NewTodoExp() // see above >> ;

Type        : bool                                                                  << ast.NewTodoExp() // bool >>
            | int                                                                   << ast.NewTodoExp() // int >>
            | tez                                                                   << ast.NewTodoExp() // tez >>
            | string                                                                << ast.NewTodoExp() // string >>
            | keyhash                                                               << ast.NewTodoExp() // key_hash >>
            | operation                                                             << ast.NewTodoExp() // operation >>
            | Type list                                                             << ast.NewTodoExp() // list >>
            | Type ast Type                                                         << ast.NewTodoExp() // tuple >>
            | lident                                                                << ast.NewTodoExp() // declaredtype >> ;

Constant    : keyhash
            | true
            | false
            | int_lit
            | float_lit
            | tez_lit
            | string_lit
            | lparen rparen
            | lbrack Constant rbrack ;





















