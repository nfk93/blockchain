21/02-2019
On the Interaction Between Consensus- and Transaction Layer:
   We have decided to limit the scope of the consensus layer to making a totally ordered broadcast. This way it is entirely decoupled 
from knowing the state of the blockchain. The consensus layer sends blocks to the transaction layer, and the transaction layer is
then responsible for applying all the contents of the block to its current state (possibly delegating execution of smart contracts to
the smart contract layer). This way, the transaction layer will build its own tree consisting of states where each node in the tree
corresponds to a block it was sent by the consensus layer. 
   When the consensus layer switches its head to a new branch, the transaction layer can then simply go back to the state at which the 
branching happened and apply the blocks from the new branch.
   Ultimately, this means that the contents of a block is only executed when it is the part of the branch at which the consensus layer 
has its head, which means that we wont have to process the contents of unnecessary blocks. It also saves memory because we don't 
have to store states that will never be used because they sit in a branch that was never active.
   At finalization, the transaction layer can then discard all its previous states. It is unclear at this moment which layer will handle
finalization, but most likely it will be the consensus layer.

25/02-2019
On the P2P layer:
   We have decided to implement our own rudimentary p2p layer, rather than use a preexisting package. We have chosen to
do this to maintain tight control with how networking works in our project.
   This choice does immediately make our project extremely vulnerable to known attacks against poorly implemented P2p
networks, however, given the modular design we plan on implementing, this toy p2p network layer should be easy to
replace with a more robust solution, such as the go-etherium p2p package
https://godoc.org/github.com/ethereum/go-ethereum/p2p